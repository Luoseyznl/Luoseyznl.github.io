---
title: C嘎嘎
date: 2025-08-24
category: 渐入佳境
tags: [编程, C++, 学习笔记]
---

C++ 是一种面向对象的编译型编程语言，结合 CMake, Bazel 等构建工具，可以高效地进行大型项目的开发和管理。其编译过程包括：预处理、编译、汇编三个阶段。预处理阶段处理头文件、宏、条件编译等指令；编译阶段将预处理后的代码转换为汇编代码；汇编阶段将汇编代码转换为机器码；编译完成后进行链接，将多个目标文件和库文件链接成可执行文件。

> 注意：这里的“链接”是指程序中的符号（如函数、变量）在各目标文件和库之间的解析与合并。C++ 的编译阶段只检查语法和生成目标文件，不涉及符号解析。链接阶段才负责将各目标文件和库中的符号解析并合并成最终的可执行文件。

> 为了方便管理和复用代码，C++ 通常将声明和定义分离。头文件（`.h` 或 `.hpp`）用于声明函数、类、变量等接口，源文件（`.cpp`）用于实现具体功能。通过包含头文件，源文件可以访问其他模块的接口。比如我们调用某个三方库，需要包含该库的头文件以获得函数和类的声明，然后在链接阶段将该库的二进制文件链接进来。

> 如果源文件中包含了第三方库的头文件（如 `#include <library.h>`），预处理阶段会将该头文件的内容插入到源文件中，编译阶段会检查这些声明的语法正确性，但不会检查其定义是否存在。只有在链接阶段，编译器才会尝试解析这些符号，并需要链接对应的库文件（如 `-llibrary`）才能成功生成可执行文件。

结合 GCC 编译器来理解 C++ 的编译与链接的过程：

1. 预处理 `g++ -E source.cpp header.h -o source.i` 生成预处理文件 `source.i`（纯文本）
2. 编译 `g++ -S source.i -o source.s` 生成汇编文件 `source.s`（汇编代码）
3. 汇编 `g++ -c source.s -o source.o` 生成目标文件 `source.o`（机器码）
4. 链接 `g++ source.o -o executable -llibrary` 生成可执行文件 `executable`（链接第三方库）

## 目录

## 1. C++ 基础

### 1.1 内存管理

C/C++ 程序在编译和链接后生成的可执行文件会被划分为多个逻辑段（section），在程序加载时就已确定：

- `.text` 段：存放程序的**机器指令代码**（即函数实现部分），只读。
- `.data` 段：存放**已初始化的全局变量和静态变量**，可读写。
- `.bss` 段：存放**未初始化的全局变量和静态变量**，在程序加载时自动清零。
- `.rodata` 段：存放**只读常量数据**，如字符串字面量、`const` 修饰的全局变量等。

C/C++ 的内存管理主要包括自动管理（比如栈）和手动管理（比如堆）两种方式：

- 自动管理：由**编译器自动分配和释放**，适用于局部变量和函数调用栈，分配速度快但大小有限。
- 手动管理：由**程序员手动分配和释放**，适用于动态分配的对象，大小受限于系统虚拟内存，但易泄漏内存。

在程序运行时，C++ 的内存主要分为栈（stack）和堆（heap）两个区域。 自动管理对应于栈上的内存分配，手动管理则对应于堆上的内存分配。合理使用栈和堆，有助于提升程序的性能和安全性。

> **malloc/free 和 new/delete 的区别？**
> 前者是 C 语言的内存分配函数，返回 `void*` 指针，不调用构造函数；后者是 C++ 的运算符，返回具体类型指针，调用构造函数。使用 new/delete 更符合 C++ 的面向对象特性。

> 结构体和类的区别？
> 结构体默认成员是公有的，类默认成员是私有的。结构体通常用于简单的数据聚合，类用于封装数据和行为。两者都可以包含成员函数、访问控制等。内存分配按成员声明顺序，且编译器会进行对齐填充（编译优化）。

### 1.2 编译选项与编译优化

1. RVO（Return Value Optimization）/ NRVO（Named Return Value Optimization）

编译器直接在调用者栈上构造返回值对象，避免返回值拷贝。RVO 适用于匿名临时对象，NRVO 适用于具名对象。

关闭 RVO/NRVO：
```sh
g++ -fno-elide-constructors source.cpp -o executable
```
```cpp
Myclass func() {
    Myclass obj;
    return obj; // NRVO
}

Myclass func() {
    return Myclass(); // RVO
}

// 关闭 RVO/NRVO 后
int main() {
    Myclass obj = func(); // 1. 在 func 栈上构造 obj 
                          // 2. func return 时调用拷贝构造到 main 栈上一个临时对象
                          // 3. 再次调用拷贝构造到 obj
}
```


### 1.2 关键字解析

1. `const`：常量修饰符，必须初始化、在 C++ 中为内部链接、在 C 中为外部链接。

    - const 搭配指针时，分为顶层 const（指针自身不可改）和底层 const（指针指向的内容不可改）。
    - const 搭配函数时，分为输入参数的 const（函数内部不可修改）和返回值的 const（返回值不可修改）。const 成员函数（函数内部不可修改成员变量）和非常量成员函数（函数内部可修改成员变量）。
    -  constexpr 常量表达式：在编译时求值的常量，通常用于优化和提高性能；隐含 inline，外部链接。

2. `static`：静态存储修饰符，可用于**延长变量声明周期**或者**限制其链接性**。

   - static 修饰全局变量/函数时，表示**内部链接**，只能在当前文件访问，防止命名冲突。
   - static 修饰局部变量时，表示**静态存储期**，但作用域仅限于函数内部。（无链接）
   - static 修饰类成员时，表示**类级别共享**，所有对象共享同一份数据。（外部链接）
   - 特别注意：静态成员变量必须在类外初始化（除非是 inline static 或 constexpr）。静态成员函数没有 this 指针，所以无法访问 static 以外的成员。

3. `extern`：外部链接修饰符，不分配存储空间，用于声明在其他文件定义的变量或函数。

   - extern 修饰全局变量/函数时，表示**外部链接**，可以在其他文件访问。不适用于局部变量。
   - extern "C"：用于 C++ 代码中声明 C 语言的函数，防止名称改编（name mangling），确保链接正确。
   ```cpp
   extern "C" {
       #include "avcodec.h"
   }
   ```

4. `inline`：内联函数修饰符，建议编译器将函数体在调用处展开，减少函数调用开销。或用来修饰变量，允许在多个文件定义同名 inline 变量，只要定义相同。

   - 全局 inline 函数和变量具有**外部链接**，但允许在多个文件定义同名 inline 函数/变量，只要定义相同。
   - 类内定义的成员函数隐含 inline，建议编译器内联展开。inline static 成员变量/函数允许在类内定义。

### 2. C++ 面向对象

C++ 默认生成 6 个特殊成员函数。如果自定义了其中任何一个，编译器可能不会自动生成其他相关函数。

- 构造函数：默认（无参数或默认参数）、有参数、委托、explicit（防止隐式转换）、delete（禁用）
- 析构函数：析构函数不可重载、不可抛出异常；可以定义为虚析构 virtual 函数。
- 拷贝构造函数：`ClassName(const ClassName &other)`，默认浅拷贝。
- 移动构造函数：`ClassName(ClassName &&other)`，other 置于有效但未定义状态。noexcept 提高性能。
- 拷贝赋值运算符：`ClassName& operator=(const ClassName &other)`，返回 *this，避免自赋值。
- 移动赋值运算符：`ClassName& operator=(ClassName &&other)`，同上。

---

- **多态**

多态是 C++ 的核心特性之一（还有封装和继承）。多态可以分为编译时多态（静态多态）和运行时多态（动态多态）。意思是同一个函数调用在不同的上下文中表现出不同的行为。

- 静态多态：通过函数重载和模板实现，在编译时决定调用哪个函数版本。
- 动态多态：通过虚函数和继承实现，在运行时根据对象的实际类型决定调用哪个函数版本。
  1. 虚函数：在基类以 `virtual` 声明， 在子类以 `override` 重写。由基类指针/引用指向的对象决定。
  2. 纯虚函数：在基类以 `= 0` 声明，包含纯虚函数的类称为抽象类，不能实例化对象。（纯虚析构必须实现）
  3. 虚析构函数：在基类以 `virtual` 声明，确保通过基类指针删除派生类对象时调用派生类的析构函数。

> **虚函数表（vtable）和虚指针（vptr）**
> 每个包含虚函数的类都有一个虚函数表，存储该类的虚函数地址。每个对象实例包含一个指向其类的虚函数表的指针（vptr）。通过基类指针调用虚函数时，编译器通过 vptr 查找 vtable，动态决定调用哪个函数实现。因此，使用虚函数会增加内存开销（vptr）和运行时开销（动态查找）。

> **虚继承（菱形继承）**
> 一个派生类可以同时继承多个基类（多重继承），当多个基类有共同的祖先类时，可能会导致菱形继承问题。虚继承通过在继承时使用 `virtual` 关键字，编译器会为每个虚继承的派生类对象增加一个虚基类指针（vbptr），指向一个虚基类表（vbtable），用于定位真正的虚基类实例。虚继承会增加对象的内存开销和访问虚基类成员的运行时开销。




## 2. 排序算法

- 快排

vector<int> sortArray(vector<int>& nums) {
    quickSort(nums, 0, nums.size() - 1);
    return nums;
}

void quickSort(vector<int>& nums, int left, int right) {
    if (left >= right) return;
    int pivot = partition(nums, left, right);
    quickSort(nums, left, pivot - 1);
    quickSort(nums, pivot + 1, right);
}

void partition(vector<int>& nums, int left, int right) {
    int pivot = nums[right];
    for (int i = left; i < right; ++i) {
        if (nums[i] <= pivot) {
            swap(nums[i], nums[left]);
            ++left;
        }
    }
    swap(nums[left], nums[right]);
    return left;
}
