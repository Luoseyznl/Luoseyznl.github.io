---
title: 计算机网络
date: 2025-07-30
category: 温故知新
tags: [计算机网络, TCP/IP, HTTP, 网络协议]
---

计网本质上是一些协议的集合，人为制定了一些规则来规范计算机之间的通信。计算机网络的学习可以分为以下几个部分：

# 1. 网络体系

计算机分层模型的设计初衷是为了模块化网络协议，使得每一层都可以独立地进行设计和实现。常见的分层模型有 OSI 七层模型和 TCP/IP 四层模型。

OSI 七层模型包括：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。TCP/IP 模型则简化为四层：网络接口层、网络层、传输层和应用层（将会话层和表示层合并为应用层）。

| 层名         | 协议举例                                                                                   |
|:------------:|:------------------------------------------------------------------------------------------|
| 网络接口层   | Ethernet, WiFi, PPP, Frame Relay, ATM, FDDI, Token Ring, ARP, RARP                        |
| 网络层       | IP (IPv4/IPv6), ICMP, IGMP, IPSec                                                         |
| 传输层       | TCP, UDP, SCTP, DCCP                                                                      |
| 应用层       | HTTP, HTTPS, FTP, SMTP, POP3, IMAP, DNS, Telnet, SSH, DHCP, SNMP, NTP, LDAP, RTP, SIP 等  |


- 数据链路层设备简介
  - 网卡（NIC, Network Interface Card）
    有唯一的 MAC 地址，常见有 Ethernet 网卡、WiFi 网卡等。用于直接连接到物理介质（交换机或路由器）。

  - 交换机（Switch）
    根据 MAC 地址表转发数据帧。连接同一局域网内的设备，负责局域网内部通信。

  - 路由器（Router）
    根据 IP 地址和路由表转发路径。连接不同网络（如局域网和广域网），负责跨网络通信（也是内网的网关）。

  - 网关（Gateway）
    通常是路由器的功能，连接不同协议或网络。可以是硬件设备或软件服务。路由器、防火墙、代理服务器。


![Communication](Communication.drawio.png)

## 1.1 应用层
应用层是用户直接交互的层。常见的应用层协议有 HTTP、HTTPS、FTP、SMTP、POP3、IMAP、DNS 等。

HTTP 是 Web 的基础协议，使用请求/响应模型。通常使用 TCP 端口 80，HTTPS 则在此基础上增加了 SSL/TLS 加密，使用端口 443。

根据 RFC 7230，GET 请求语义是请求获取指定资源（静态 HTML 文本、图片、视频等），参数一般写在 URL 中（只支持 ASCII 字符）。请求头部包含 Host、User-Agent、Accept 等字段。POST 提交表单请求则是根据 GET 报文体的内容进行处理，将数据放在请求体中。

![HTTP](HTTP.drawio.png)

```
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
Accept: text/html,application/xhtml+xml,application/xml;q=0.9
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9
Connection: keep-alive
Referer: https://www.example.com/home
Cookie: sessionid=abc123; theme=dark
Authorization: Basic dXNlcjpwYXNz
If-Modified-Since: Wed, 21 Oct 2025 07:28:00 GMT
If-None-Match: "abc123"
Content-Type: application/x-www-form-urlencoded
Content-Length: 27

username=alice&password=123456
```

### 1.1.1 HTTP 安全和幂等

对于 HTTP 请求有安全和幂等的概念，
- 安全（Safe）：请求不会对服务器资源造成副作用。
- 幂等（Idempotent）：多次请求同一资源，结果相同。

    | 方法   | 安全（Safe） | 幂等（Idempotent） | 说明                         |
    |--------|:------------:|:------------------:|------------------------------|
    | GET    | 是           | 是                 | 获取资源，不修改服务器数据    |
    | HEAD   | 是           | 是                 | 类似 GET，只返回响应头        |
    | OPTIONS| 是           | 是                 | 查询服务器支持哪些方法        |
    | PUT    | 否           | 是                 | 更新/替换资源                |
    | DELETE | 否           | 是                 | 删除资源                     |
    | POST   | 否           | 否                 | 新建资源或提交数据|
    | PATCH  | 否           | 否                 | 局部更新资源|

### 1.1.2 HTTP 缓存技术

HTTP 支持缓存技术，将多次请求相同资源的响应结果缓存起来，减少网络传输和服务器负担。

1. 强制缓存：由浏览器判断是否使用缓存（只要缓存未过期），通过响应头中的 Cache-Control 和 Expires 字段来控制。
   - `Cache-Control: max-age=3600`：相对时间，缓存有效期为 1 小时。
   - `Expires: Wed, 21 Oct 2025 07:28:00 GMT`：绝对时间，缓存到期时间。
   - `Cache-Control: no-cache`：不使用缓存，强制重新验证（即使用协商缓存）。

2. 协商缓存：由服务器判断是否使用缓存（对比缓存和服务器资源），通过请求头中的 If-Modified-Since 和 If-None-Match 字段，以及响应头中的 Last-Modified 和 ETag 字段来实现。
   - 在客户端收到响应头带有 Last-Modified 或 ETag 时，会在下次请求时带上 If-Modified-Since 或 If-None-Match。服务器对其进行对比，若资源修改则返回新资源 200 OK，若未修改则返回 304 Not Modified。
     - 请求头 `If-Modified-Since: Wed, 21 Oct 2025 07:28:00 GMT`：客户端发送的最后修改时间（同时发送 Last-Modified）
     - 响应头 `Last-Modified: Wed, 21 Oct 2025 07:28:00 GMT`：服务器返回的资源最后修改时间
     - 请求头 `If-None-Match: "abc123"`：客户端发送的 ETag（实体标签），唯一标识资源版本，优先级高于修改时间
     - 响应头 `ETag: "abc123"`：服务器对比 If-None-Match，若匹配则返回 304 Not Modified，否则返回新资源 200 OK

### 1.1.3 HTTP 状态码
| 状态码类别 | 说明           | 常见状态码及含义                                                                                 |
|:----------:|:--------------|:-----------------------------------------------------------------------------------------------|
| 1xx        | 提示信息       | 100 Continue：继续，收到请求的初始部分，客户端应继续发送请求的其余部分（实际很少用）             |
| 2xx        | 成功           | 200 OK：请求成功，返回数据<br>204 No Content：请求成功，无响应体<br>206 Partial Content：部分内容（用于断点续传） |
| 3xx        | 重定向         | 301 Moved Permanently：永久重定向<br>302 Found：临时重定向<br>304 Not Modified：资源未修改，可用缓存 |
| 4xx        | 客户端错误     | 400 Bad Request：请求有误<br>403 Forbidden：禁止访问<br>404 Not Found：资源不存在                |
| 5xx        | 服务器错误     | 500 Internal Server Error：服务器内部错误<br>501 Not Implemented：未实现<br>502 Bad Gateway：网关错误<br>503 Service Unavailable：服务不可用 |

### 1.1.4 HTTP 版本特性

![HTTP_version](HTTP_version.png)

1. HTTP/1.0（无状态、明文传输）
   - 无状态：每个请求独立，不保留请求状态；（可以通过 Cookie 实现会话状态）
   - 明文传输：数据以明文形式传输，易被窃听和篡改。
2. HTTP/1.1（持久连接、管道化（基本没用））
   - 持久连接：默认启用 Keep-Alive，允许在同一 TCP 连接上发送多个请求（直到主动断开或超时），减少连接开销。
   - 管道化：允许客户端在发送请求时不等待响应，同时发送多个请求，但服务器必须按顺序处理响应，减少整体响应时间。
3. HTTP/2（二进制分帧、多路复用、头部压缩）
   - 二进制分帧：将请求和响应分为头信息帧、数据帧，提高传输效率。
   - 多路复用（并发）：引入 Stream，多个流共用一个 TCP 连接。流内的 Message 包含多个 Frame（二进制的请求/响应）。
     - 通过 Stream ID 区分不同请求/响应，接收端以此顺序组装。服务器也可以主动推送流（Stream ID 是偶数）。
        ![服务器推送](push.png)
   - 头部压缩：在客户端和服务器同时维护一个头部表（Header Table），使用索引代替重复的头部字段（HPACK 算法）

HTTP/1.1 的管道化没能解决响应头阻塞问题，HTTP/2 的多路复用在丢包时也会导致所有流阻塞。本质上一个是 HTTP 层阻塞（需要按顺序响应），一个是 TCP 层阻塞（需要按顺序传输）。所以 HTTP/3 引入了基于 UDP 的 QUIC 协议（Quick UDP Internet Connections）。

4. HTTP/3（基于 QUIC 协议）
   - 无队头阻塞：丢包只会导致某个流阻塞，不会影响其他流。
   - 连接迁移：不同于传统的四元组(源 IP:Port, 目的 IP:Port)，QUIC 使用连接 ID 来标识连接，实现无缝切换。
   - 内置加密：QUIC 内部包含 TLS 1.3，仅需一个 RTT 即可完成握手，减少延迟。

### 1.1.4 HTTPS

HTTP/2 和 HTTP/3 都基于 HTTPS（HTTP over TLS），提供加密传输。HTTPS 在 HTTP 协议之上增加了 SSL/TLS 层，提供数据加密、完整性校验和身份验证。

- 数据加密：在建立连接时采用非对称加密（如 RSA）交换会话密钥；在通信时使用对称加密（如 AES）加密数据。
- 完整性校验：使用 HMAC（Hash-based Message Authentication Code）对数据进行完整性校验。
  发送端对数据进行哈希运算生成**数字摘要**，使用私钥加密生成**数字签名**。接收端使用公钥解密后对比摘要，确保数据未被篡改。

- 身份验证：使用 CA（Certificate Authority）颁发的数字证书验证服务器身份（确保公钥真实可信）。
  服务器将**数字证书**（公钥、CA 签名）发送给客户端，客户端使用 CA 公钥验证 CA 签名，确保服务器公钥可信。

![TLS](TLS.drawio.png)

### 1.1.5 RPC 

RPC（Remote Procedure Call）是一种远程过程调用协议，允许程序调用远程服务器上的函数或方法，就像调用本地函数一样。常见的 RPC 协议有 gRPC、Thrift、JSON-RPC 等。

早期 HTTP 主要用于 Browser-Server 模型的请求响应，RPC 则用于 Client-Server 模型的函数调用。RPC 协议通常使用二进制协议（如 Protobuf）进行高效序列化和反序列化。

1. 服务发现：
   - HTTP 通常通过 DNS 或负载均衡器进行服务发现。
   - RPC 协议通常使用服务注册中心（如 Consul、Etcd、Zookeeper、CoreDNS）来管理服务实例。
2. 连接方式：
   - HTTP 通常使用长连接（Keep-Alive）或短连接。
   - RPC 协议通常通过 TCP 长连接进行通信。一般还会建立连接池，复用连接以减少连接开销。
3. 传输内容：
   - HTTP 传输的是请求和响应报文，通常是 JSON、XML 等文本格式。
   - RPC 协议传输的是函数调用请求和响应，通常使用二进制格式（如 Protobuf）进行高效序列化。

## 1.2 传输层

负责将应用层（用户直接交互的层）数据分割为段，并为每段加上端口号以及其他控制信息（报文段）。传输层的协议有 TCP 和 UDP。



