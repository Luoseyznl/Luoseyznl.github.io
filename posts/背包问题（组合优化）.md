---
title: 背包问题（组合优化）
date: 2025-08-04
category: 渐入佳境
tags: [刷题, 背包问题, 组合优化, 动态规划]
---

贝尔曼年轻时为了解决阶段性决策问题，提出了动态规划。其核心思想是**最优子结构**，即一个**问题的最优解可以由其子问题的最优解构成**。在他晚年时又进一步将其拓展至控制领域，引申出最优控制理论。


## 目录

- [目录](#目录)
- [1. 组合优化问题](#1-组合优化问题)
  - [1.1 0-1 背包问题（0-1 Knapsack Problem）](#11-0-1-背包问题0-1-knapsack-problem)
  - [1.2 完全背包问题（Complete Knapsack Problem）](#12-完全背包问题complete-knapsack-problem)
  - [1.3 多重背包问题（Multiple Knapsack Problem）](#13-多重背包问题multiple-knapsack-problem)
- [2 组合优化问题其他情形](#2-组合优化问题其他情形)
  - [2.1 恰好装满背包](#21-恰好装满背包)
  - [2.2 总方案数](#22-总方案数)
  - [2.3 最优解的具体组合](#23-最优解的具体组合)

## 1. 组合优化问题

> 组合优化问题是指在给定的约束条件下，寻找最优解的组合问题。背包问题尤为经典。

### 1.1 0-1 背包问题（0-1 Knapsack Problem）

定义：在背包容量的限制下，选择物品使得总价值最大化。每个物品只能选择一次。求装满背包的最大价值。

状态定义：$dp[i][j]$ 表示前 $i$ 个物品中，能够装入容量为 $j$ 的背包的最大价值。

状态转移方程：由于每个物品只能选择一次，因此 $dp[i][j]$ 仅依赖上一层的状态。
$$
dp[i][j] = \max(dp[i-1][j], dp[i-1][j-w_i] + v_i) \quad (j \geq w_i)
$$
其中 $w_i$ 是第 $i$ 个物品的重量，$v_i$ 是第 $i$ 个物品的价值。

初始状态：$dp[0][j] = 0$（即没有物品时，背包的最大价值为 0）。二维 dp 可以优化为一维，仅需要注意内层需要逆序遍历到 $w_i$。外层遍历从第 1 个物品开始（因为第 0 个物品没有价值），内层遍历从背包容量 $n$ 开始，直到当前物品的重量 $w_i$。意思是挨个试探前 i 个物品装入容量为从大到小的 j 背包的最大价值。逆序时依赖的状态都是还未使用当前物品 i 的状态，而正序不然。

```cpp
// 滚动优化
int n = capacity;
vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));
for (int i = 1; i <= items.size(); ++i) {
    for (int j = n; j >= items[i - 1].weight; --j) {
        dp[j] = max(dp[j], dp[j - items[i - 1].weight] + items[i - 1].value);
    }
}
```

> **为什么外层遍历物品，内层遍历背包容量呢？**
> dp[j] 是由二维 dp[i][j] 优化而来，表示当前容量为 j 的背包的最大价值。外层遍历物品，表示每次考虑一个新的物品 i。内层遍历背包容量 j。如果反过来会导致误用多次同一物品的价值（比如上一步用了某物品，下一步又用了它），违反 0-1 背包的约束条件。

> **为什么内层需要逆序遍历呢？**
> 内层遍历背包容量 j，从大到小遍历，确保在计算 dp[j] 时，使用的是前 i-1 个物品的状态（即上一回合的决策结果），而不是当前回合的决策结果。避免误用当前物品多次更新 dp[j]（比如内环正序遍历时上一步刚用了当前物品，现在恰好又用它）。

### 1.2 完全背包问题（Complete Knapsack Problem）

定义：在背包容量的限制下，选择物品使得总价值最大化。每个物品可以选择多次。求装满背包的最大价值。

状态定义：$dp[i][j]$ 表示前 $i$ 个物品中，能够装入容量为 $j$ 的背包的最大价值。

状态转移方程：第 i 个物品可以选择多次，因此 dp[i][j] 的状态转移依赖于从当前行以上所有行的状态。
$$
dp[i][j] = \max(dp[i-1][j], dp[i][j-w_i] + v_i) \quad (j \geq w_i)
$$
其中 $w_i$ 是第 $i$ 个物品的重量，$v_i$ 是第 $i$ 个物品的价值。

初始状态：$dp[0][j] = 0$（即没有物品时，背包的最大价值为 0）。二维遍历顺序都必须是正序（为了能多次用上当前物品）。也正因为物品的使用不受限制，所以内外层遍历也可以互换（0-1 背包为了避免对容量 j 做判断时依赖的状态用过某物品了，所以内层逆序遍历）。

```cpp
// 滚动优化
int n = capacity;
vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));
for (int i = 1; i <= items.size(); ++i) {
    for (int j = items[i - 1].weight; j <= n; ++j) {
        dp[j] = max(dp[j], dp[j - items[i - 1].weight] + items[i - 1].value);
    }
}
```

> **内外层遍历顺序可以互换吗？**
> 可以，而且有些题目必须先遍历容量再遍历物品（比如求排列方案数的题目）。但大多数情况下，习惯先遍历物品再遍历容量。
> 求取组合数的题目要确保每种物品只用一次以实现某个阶段的目标（虽然排列不同，但相加计算后仍是同一种方案），求排列数则相当于在组合数的基础上再对物品进行全排列（所以先遍历容量再遍历物品，这样可以让不同顺序的排列方案数相加）。

### 1.3 多重背包问题（Multiple Knapsack Problem）

定义：在背包容量的限制下，选择物品使得总价值最大化。每个物品有数量限制。看作物品价值容量可变的 0-1 背包。

状态定义：$dp[i][j]$ 表示前 $i$ 种物品中，能够装入容量为 $j$ 的背包的最大价值。

状态转移方程：无非多一个内层循环，枚举第 i 个物品选择的数量 k。
$$
dp[i][j] = \max(dp[i-1][j], dp[i-1][j-k \cdot w_i] + k \cdot v_i) \quad (j \geq k \cdot w_i)
$$
其中 $w_i$ 是第 $i$ 个物品的重量，$v_i$ 是第 $i$ 个物品的价值，$k \in [0, min(nums[i], j / w_i)]$。

```cpp
// 滚动优化
int n = capacity;
vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));
for (int i = 1; i <= items.size(); ++i) {
    for (int j = n; j >= items[i - 1].weight; --j) {
        for (int k = 1; k <= nums[i - 1]; ++k) {
            if (j >= k * items[i - 1].weight) {
                dp[j] = max(dp[j], dp[j - k * items[i - 1].weight] + k * items[i - 1].value);
            }
        }
    }
}
```

> 最内层枚举每个物品的价值容量，选其最优即可，因为状态转移将其选择的所有可能性都考虑进去了。

---

## 2 组合优化问题其他情形

> 除了求取最大价值外，组合优化问题还有**恰好装满背包**、**总方案数**、**最优解的具体组合**、**分组背包**等其他情形。

### 2.1 恰好装满背包

要求组合容量恰好等与背包容量，否则视为无效解。初始化状态为 $dp[0][0] = 0$，表示没有物品时背包的最大价值为 0。而 $dp[0][j] = -\infty$（$j > 0$）表示无效解（不会被选，或者说即使选了最后也不会被计入最优解）。状态转移方程与 0-1 背包相同。

### 2.2 总方案数

计数型动态规划的初始化和状态转移方法与求最大价值的动态规划类似，但需要注意以下几点：

1. 状态转移用加法（累加方案数），而不是取 max / min。
2. 初始化时，$dp[0][0] = 1$，$dp[0][j] = 0$（$j > 0$）表示没有物品时，容量大于 0 的背包没有方案。
3. 如果是求组合方案数，内层正序遍历容量 j；如果是求排列方案数，外层正序遍历容量 j。

[零钱兑换 II：求方案数（完全背包）](https://leetcode.cn/problems/coin-change-ii/)

```cpp
// 恰好装满背包的总方案数（完全背包）
int change(int amount, vector<int>& coins) {
    vector<int> dp(amount + 1, 0);
    dp[0] = 1; // 和为 0 时，空集也算一种方式

    // 硬币可以取用多次（完全背包）
    for (int coin : coins) {
        for (int j = coin; j <= amount; ++j) {
            dp[j] += dp[j - coin];
        }
    }
    return dp[amount];
}
```

[组合总和](https://leetcode.cn/problems/combination-sum-iv/)

```cpp
// 恰好装满背包的总方案数（排列数）
int combinationSum4(vector<int>& nums, int target) {
    vector<int> dp(target + 1, 0);
    dp[0] = 1; // 和为 0 时，空集也算一种方式
    // 先遍历容量，再遍历物品（排列数）
    for (int j = 1; j <= target; ++j) {
        for (int i = 0; i < nums.size(); ++i) {
            if (j >= nums[i]) {
                dp[j] += dp[j - nums[i]];
            }
        }
    }
    return dp[target];
}
```

> 正所谓“心外有物，物不重复；心外有量，以量取物”。意思是外层遍历物品时，物品不重复使用（组合）；外层遍历容量时，物品可以重复使用（排列）。

### 2.3 最优解的具体组合

1. 状态记录法

在状态转移过程中记录每次选取的物品编号或数量。最后通过回溯这些记录来构建最优解的具体组合。

```cpp
// 记录选择的物品
vector<vector<int>> selectedItems(items.size() + 1, vector<int>(capacity + 1, 0));
for (int i = 1; i <= items.size(); ++i) {
    for (int j = 0; j <= capacity; ++j) {
        if (dp[i][j] != dp[i-1][j]) {
            selectedItems[i][j] = 1;
            j -= items[i-1].weight;
        }
    }
}
```

2. 回溯法

回溯法适用于 0-1 背包问题。通过递归尝试每个物品的选与不选，直到找到所有满足条件的组合。

```cpp
void backtrack(vector<int>& items, int idx, int remain, vector<int>& path, vector<vector<int>>& res) {
    if (remain == 0) {
        res.push_back(path); // 找到一个可行组合
        return;
    }
    if (remain < 0 || idx == items.size()) return;
    // 不选当前物品
    backtrack(items, idx + 1, remain, path, res);
    // 选当前物品
    path.push_back(items[idx]);
    backtrack(items, idx + 1, remain - items[idx], path, res);
    path.pop_back();
}
```


> 除了用于求解背包问题，动态规划还广泛应用于字符串处理、路径规划、资源分配等领域。其中心思想是将复杂问题分解为更简单的子问题，通过保存子问题的解来避免重复计算，从而提高效率。

