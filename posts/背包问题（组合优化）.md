---
title: 背包问题（组合优化）
date: 2025-08-04
category: 渐入佳境
tags: [刷题, 背包问题, 组合优化, 动态规划]
---

贝尔曼年轻时为了解决阶段性决策问题，提出了动态规划。其核心思想是**最优子结构**，即一个**问题的最优解可以由其子问题的最优解构成**。在他晚年时又进一步将其拓展至控制领域，引申出最优控制理论。

---

## 目录

- [1. 组合优化问题](#1-组合优化问题)
  - [1.1 0-1 背包问题（0-1 Knapsack Problem）](#11-0-1-背包问题0-1-knapsack-problem)
  - [1.2 完全背包问题（Complete Knapsack Problem）](#12-完全背包问题complete-knapsack-problem)
  - [1.3 多重背包问题（Multiple Knapsack Problem）](#13-多重背包问题multiple-knapsack-problem)
- [2 组合优化问题其他情形](#2-组合优化问题其他情形)
- [3. 常见组合优化问题](#3-常见组合优化问题)

---

# 1. 组合优化问题

> 组合优化问题是指在给定的约束条件下，寻找最优解的组合问题。背包问题尤为经典。


## 1.1 0-1 背包问题（0-1 Knapsack Problem）

定义：在背包容量的限制下，选择物品使得总价值最大化。每个物品只能选择一次。

状态定义：$dp[i][j]$ 表示前 $i$ 个物品中，能够装入容量为 $j$ 的背包的最大价值。

状态转移方程：
$$
dp[i][j] = \max(dp[i-1][j], dp[i-1][j-w_i] + v_i) \quad (j \geq w_i)
$$
其中 $w_i$ 是第 $i$ 个物品的重量，$v_i$ 是第 $i$ 个物品的价值。

初始状态：$dp[0][j] = 0$（即没有物品时，背包的最大价值为 0）。该问题的第一个约束是背包容量，通过动态规划建表（$j$ 表示背包容量），将问题抽象为阶段性决策。第二个约束是每个物品只有选或不选两种选择，前 $i$ 个物品的最优决策完全依赖于前 $i-1$ 个物品的决策结果。

```cpp
// 滚动优化
int n = capacity;
vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));
for (int i = 1; i <= items.size(); ++i) {
    for (int j = n; j >= items[i - 1].weight; --j) {
        dp[j] = max(dp[j], dp[j - items[i - 1].weight] + items[i - 1].value);
    }
}
```
0-1 背包由于其 $i$ 物品的选择依赖于 $i-1$ 物品的状态（上一回合决策过程），因此 $j$ 需要逆向遍历，避免覆盖上一回合决策。（你覆盖他干啥，这值我还有用呢！）

## 1.2 完全背包问题（Complete Knapsack Problem）

定义：在背包容量的限制下，选择物品使得总价值最大化。每个物品可以选择多次。

状态定义：$dp[i][j]$ 表示前 $i$ 个物品中，能够装入容量为 $j$ 的背包的最大价值。

状态转移方程：
$$
dp[i][j] = \max(dp[i-1][j], dp[i][j-w_i] + v_i) \quad (j \geq w_i)
$$
其中 $w_i$ 是第 $i$ 个物品的重量，$v_i$ 是第 $i$ 个物品的价值。

初始状态：$dp[0][j] = 0$（即没有物品时，背包的最大价值为 0）。该问题的第一个约束是背包容量，通过动态规划建表（$j$ 表示背包容量），将问题抽象为阶段性决策。第二个约束是每个物品可以选择多次，前 $i$ 个物品的决策依赖于当前回合的决策过程。

```cpp
// 滚动优化
int n = capacity;
vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));
for (int i = 1; i <= items.size(); ++i) {
    for (int j = items[i - 1].weight; j <= n; ++j) {
        dp[j] = max(dp[j], dp[j - items[i - 1].weight] + items[i - 1].value);
    }
}
```
完全背包由于其 $i$ 物品的选择依赖于当前回合的状态（当前决策过程），因此 $j$ 需要正向遍历，允许多次选择同一物品。（赶紧覆盖，覆盖完了我再用！）

## 1.3 多重背包问题（Multiple Knapsack Problem）

定义：在背包容量的限制下，选择物品使得总价值最大化。每个物品有固定的数量限制。

状态定义：$dp[i][j]$ 表示前 $i$ 个物品中，能够装入容量为 $j$ 的背包的最大价值。

状态转移方程：
$$
dp[i][j] = \max(dp[i-1][j], dp[i-1][j-k \cdot w_i] + k \cdot v_i) \quad (j \geq k \cdot w_i)
$$
其中 $w_i$ 是第 $i$ 个物品的重量，$v_i$ 是第 $i$ 个物品的价值，$k \in [0, min(nums[i], j / w_i)]$。

```cpp
// 滚动优化
int n = capacity;
vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));
for (int i = 1; i <= items.size(); ++i) {
    for (int j = n; j >= items[i - 1].weight; --j) {
        for (int k = 1; k <= nums[i - 1]; ++k) {
            if (j >= k * items[i - 1].weight) {
                dp[j] = max(dp[j], dp[j - k * items[i - 1].weight] + k * items[i - 1].value);
            }
        }
    }
}
```

---

# 2 组合优化问题其他情形

> 除了求取最大价值外，组合优化问题还可以求取总方案数、最优解的具体组合、或是恰好装满背包的最大价值等。

1. 总方案数

将状态定义为 $dp[i][j]$ 表示前 $i$ 个物品中，能够装入容量为 $j$ 的背包的方案数。状态转移方程为：
$$
dp[i][j] = dp[i-1][j] + dp[i-1][j-w_i] \quad (j \geq w_i)
$$
其中 $w_i$ 是第 $i$ 个物品的重量。

2. 最优解的具体组合

在状态转移过程中，记录每次选择的物品编号或数量。可以使用一个额外的数组 $$selectedItems[i][j]$$ 来记录是否选择了第 $i$ 个物品（0或1表示未选择或已选择）。

```cpp
// 记录选择的物品
vector<vector<int>> selectedItems(items.size() + 1, vector<int>(capacity + 1, 0));
for (int i = 1; i <= items.size(); ++i) {
    for (int j = 0; j <= capacity; ++j) {
        if (dp[i][j] != dp[i-1][j]) {
            selectedItems[i][j] = 1;
            j -= items[i-1].weight;
        }
    }
}
```

3. 恰好装满背包的最大价值

初始化状态为 $dp[0][0] = 0$，表示没有物品时背包的最大价值为 0。而 $dp[0][j] = -\infty$（$j > 0$）表示无法装满背包。状态转移方程为：
$$
dp[i][j] = \max(dp[i-1][j], dp[i-1][j-w_i] + v_i) \quad (j \geq w_i)
$$
其中 $w_i$ 是第 $i$ 个物品的重量，$v_i$ 是第 $i$ 个物品的价值。

---

# 3. 常见组合优化问题

1. 等和子集：问题描述：给定一组正整数，判断是否可以将其划分为两个子集，使得两个子集的和相等。
   - 状态定义：$dp[i][j]$ 表示前 $i$ 个数能否组成和为 $j$ 的子集。
   - 状态转移方程：$dp[i][j] = dp[i-1][j] \lor dp[i-1][j-a_i]$（$a_i$ 是第 $i$ 个数）。
    ```cpp
    int aggregate = accumulate(nums.begin(), nums.end(), 0);
    if (aggregate % 2 != 0) return false; // 总和为奇数不能拆分成两个等和子集
    int target = aggregate / 2;

    vector<bool> dp(target + 1, false); // 前 i 个数能否组成和为 j 的子集
    dp[0] = true; // 和为 0 时，空集可以组成（恰好 0-1 背包）
    for (int i = 1; i <= nums.size(); ++i) {
        for (int j = target; j >= nums[i-1]; --j) {
            dp[j] = dp[j] || dp[j - nums[i-1]];
        }
    }
    return dp[target];
    ```
2. 零钱兑换：给定不同面额的硬币和一个总金额，计算可以凑成该金额的硬币组合数。
   - 状态定义：$dp[i][j]$ 表示前 $i$ 种硬币组合成金额 $j$ 的方式数。
   - 状态转移方程：$dp[i][j] = dp[i-1][j] + dp[i][j-a_i]$（$a_i$ 是第 $i$ 种硬币的面额）。
    ```cpp
    vector<int> dp(amount + 1, 0);
    dp[0] = 1; // 和为 0 时，空集也算一种方式

    // 硬币可以取用多次（完全背包）
    for (int coin : coins) {
        for (int j = coin; j <= amount; ++j) {
            dp[j] += dp[j - coin];
        }
    }
    return dp[amount];
    ```
3. 目标和：给定一个整数数组和一个目标值，通过对数组中的数加上正负号得到目标值的组合方式数。
   - 状态定义：$dp[i][j]$ 表示前 $i$ 个数组合成和为 $j$ 的方式数。
    ```cpp
    // A + B = aggregate
    // A - B = target
    // A = (aggregate + target) / 2
    int aggregate = accumulate(nums.begin(), nums.end(), 0);
    if ((aggregate + target) % 2 != 0 || aggregate < target) return false; // 不满足条件
    int targetSum = (aggregate + target) / 2;

    vector<int> dp(targetSum + 1, 0);
    dp[0] = 1; // 和为 0 时，空集也算一种方式
    for (int num : nums) {
        for (int j = targetSum; j >= num; --j) {
            dp[j] += dp[j - num];
        }
    }
    return dp[targetSum];
    ```
