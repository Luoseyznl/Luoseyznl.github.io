---
title: 操作系统学习笔记
date: 2025-07-28
category: 渐入佳境
tags: [操作系统, 进程管理, 内存管理, 文件系统]
---

操作系统的知识可以分为五个部分：**进程管理**、**内存管理**、**文件系统**、**设备管理**、**网络系统**。这里的网络系统主要是操作系统如何处理网络通信。仅仅照着知识抄笔记是没有用的，重要的是通过理解结合实践来形成自己的知识体系，并且有能力表达出来。

---

## 目录
- [1. 进程管理](#1-进程管理)
  - [1.1 进程](#11-进程)
    - [1.1.1 进程状态](#111-进程状态)
    - [1.1.2 进程控制](#112-进程控制)
    - [1.1.3 进程的上下文切换](#113-进程的上下文切换)
  - [1.2 线程](#12-线程)
    - [1.2.1 线程模型](#121-线程模型)
  - [1.3 调度](#13-调度)
- [2. 内存管理](#2-内存管理)
  - [2.1 虚拟内存映射](#21-虚拟内存映射)
    - [2.1.1 分段](#211-分段)
    - [2.1.2 分页](#212-分页)
    - [2.1.3 段页式管理](#213-段页式管理)
  - [2.2 Linux 内存管理](#22-linux-内存管理)
- [3. 文件系统](#3-文件系统)
  - [3.1 文件系统概述](#31-文件系统概述)
  - [3.1 虚拟文件系统（VFS）](#31-虚拟文件系统vfs)
  - [3.2 文件描述符](#32-文件描述符)
  - [3.3 文件存储](#33-文件存储)
  - [3.4 磁盘空间管理](#34-磁盘空间管理)
  - [3.5 符号链接和硬链接](#35-符号链接和硬链接)
  - [3.6 I/O 类型](#36-io-类型)
    - [1. 缓冲与非缓冲 I/O](#1-缓冲与非缓冲-io)
    - [2. 直接与非直接 I/O](#2-直接与非直接-io)
    - [3. 阻塞与非阻塞 I/O](#3-阻塞与非阻塞-io)
    - [4. 同步与异步 I/O](#4-同步与异步-io)

---

# 1. 进程管理

## 1.1 进程

### 1.1.1 进程状态

进程（process）定义为正在执行的程序的实例。它是操作系统资源分配和调度的基本单位。一个完整的进程状态变迁包括：

![process_state](process_state.drawio.png)

为了避免阻塞状态的进程占据物理内存，虚拟内存技术允许操作系统将阻塞进程的数据存储在磁盘上，只有在需要时才加载到内存中。因此需要一个中间状态描述进程没有占据物理内存的状态 —— **挂起状态**。挂起状态可分为两种：挂起就绪（进程在外存，只要进入内存就执行）和挂起阻塞（进程在外存等待）。

![process_state2](process_state2.drawio.png)

进程挂起的原因有：系统资源不足、进程主动挂起、操作系统调度策略、用户 Ctrl + C/Ctrl + Z 等。

---

### 1.1.2 进程控制

进程控制块（PCB）是操作系统用来管理进程的核心数据结构。它包含了进程的所有信息：

- 进程标识信息：如进程ID（pid）、用户ID（uid），用于唯一标识和归属进程。
- 进程状态信息：记录进程当前所处的状态（如新建、就绪、运行、阻塞、挂起等）。
- 优先级和调度信息：进程的优先级、调度相关参数，决定进程获得CPU的顺序。
- 资源分配信息：进程所占用的内存空间、打开的文件列表、使用的I/O设备等资源清单。
- CPU相关信息：如寄存器内容、程序计数器（PC）、堆栈指针等，用于进程切换时保存和恢复运行环境。
- 进程间关系信息：如父进程、子进程等层级关系。

将具有相同状态的进程的 PCB 链在一起，组成各种队列：就绪队列、阻塞队列、挂起就绪队列、挂起阻塞队列等。CPU 的核心（执行硬件单元）通过调度算法从就绪队列中选择一个进程执行。调度算法可以是先来先服务（FCFS）、短作业优先（SJF）、轮转（RR）等。

进程控制指的是操作系统对进程的创建、终止、阻塞、唤醒等操作。进程的创建通常由系统调用 `fork()` 实现，它会复制当前进程的 PCB，分配资源后插入就绪队列。新创建的进程会获得一个新的进程ID（pid），并且其父进程ID（ppid）指向原进程。终止进程则通过 `exit()` 系统调用完成，操作系统会清理该进程的资源并更新相关队列。阻塞进程通常是因为等待某些事件（如I/O操作完成），进程也可以主动调用 `sleep()` 等函数进入阻塞状态。一旦进程被阻塞只能等待事件的发生或由其他进程唤醒。

---

### 1.1.3 进程的上下文切换

操作系统在多任务环境下，保存当前进程的状态信息（上下文）在 PCB 中，并从另一个进程的 PCB 中加载状态信息。进程的状态信息（上下文）包括：用户空间的虚拟内存、全局变量、栈，还包括内核空间的内核堆栈、寄存器内容等。上下文切换一般发生在：进程时间片用完、进程阻塞等待I/O、进程主动让出CPU等。

---

## 1.2 线程

线程是相对于进程更小的，独立运行的基本执行单位。线程既可以并发运行（具有自己的寄存器状态和栈），同时又共享进程的资源（如内存空间、文件描述符等）。线程的创建和管理比进程更轻量级，因为线程之间的切换不需要像进程那样保存和恢复完整的上下文。对于同一进程内的线程，切换时只需切换不共享的数据（私有数据、寄存器）即可。线程的缺点是，当一个线程崩溃时，整个进程都会受到影响，因为它们共享同一地址空间。

**总结：** 线程是进程中的一条执行流程。两者相比，线程的创建和销毁开销更小，切换速度更快，但线程之间的共享资源也带来了更多的同步和安全问题。

---

### 1.2.1 线程模型

目前主要有三种线程模型：

- **用户级线程（ULT）**：由用户空间的库管理，内核不感知线程的存在。
- **内核级线程（KLT）**：由操作系统内核直接管理，内核可以调度和管理每个线程。
- **轻量级进程（LWP）**：介于两者之间，允许多个用户级线程映射到一个或多个内核级线程（多对一、一对一、多对多）。

**用户线程的优缺点：**
- 优点：TCB 由用户空间的线程库函数管理，无需内核支持，切换速度快。
- 缺点：内核无法感知用户线程，无法进行调度和管理，可能导致线程饥饿。

**内核线程的优缺点：**
- 优点：内核可以调度和管理，支持多核并行。
- 缺点：切换时需要用户态和内核态切换，速度较慢，内核开销大。

**轻量级进程（LWP）：**
- 一对一：每个用户线程对应一个内核线程。
- 多对一：多个用户线程对应一个内核线程。
- 一对多：一个用户线程对应多个内核线程。

---

## 1.3 调度

线程才是操作系统调度的基本单位。调度算法决定了哪个线程在何时获得 CPU 的使用权。在进程状态切换时会触发调度（操作系统需要考虑当前进程的状态和优先级）。

调度类型：
- **非抢占式调度**：操作系统不会在进程运行时强制切换进程，只有在进程主动让出 CPU 或阻塞时才进行调度。
- **抢占式调度**：操作系统可以在任何时候强制切换进程，通常是通过硬件时钟中断来实现。

调度算法应考虑：CPU 利用率、系统吞吐量、周转时间、等待时间、响应时间、公平性。

**常见调度算法：**
1. 先来先服务（FCFS）
2. 短作业优先（SJF）
3. 时间片轮转（RR）
4. 优先级调度
5. 多级反馈队列（MLFQ）

---

# 2. 内存管理

单片机的 CPU 直接操作物理内存，无法并发运行多个程序。操作系统通过虚拟内存技术为每个进程分配独立的虚拟地址空间。每个进程只能访问自己的虚拟地址空间，操作系统通过页表将虚拟地址映射到物理地址。

---

## 2.1 虚拟内存映射

### 2.1.1 分段

程序由若干逻辑分段组成（代码段、数据段、堆栈段），每个分段有一个起始地址和长度。分段机制下虚拟内存地址由两部分组成：段选择因子和段内偏移量。分段优点是可按程序逻辑分配内存，缺点是可能导致外部碎片。

---

### 2.1.2 分页

分页将虚拟内存划分为固定大小的页（Page），物理内存划分为页框（Page Frame），通过页表实现虚拟地址到物理地址的映射。分页优点是消除外部碎片，缺点是可能有内部碎片和页表开销。为减少页表大小，操作系统可用多级页表。CPU 中的 TLB（页表缓存）可加速地址转换。

| 分段 | 分页 |
|---|---|
| ![segmentation](segmentation.png) | ![paging](paging.png) |

---

### 2.1.3 段页式管理

段页式管理结合了分段和分页的优点。先将虚拟地址空间划分为逻辑段，每个段再划分为固定大小的页。物理转换需三步：

1. 通过段选择因子找到段表，获取段基地址和段界限。
2. 通过段内偏移量找到页表，获取页框号。
3. 将页框号与段基地址（页内偏移量）相加，得到物理地址。

---

## 2.2 Linux 内存管理

Intel 早期 x86 架构支持分段，后来转向段页式管理。Linux 基本不使用分段机制做隔离和保护，而是让所有段基地址为 0，界限最大，虚拟地址直接等于线性地址，只有分页机制在真正发挥作用。

---

# 3. 文件系统

## 3.1 文件系统概述

文件系统负责将用户数据存储在磁盘上，并提供访问和管理。Linux 文件系统为每个文件分配两个数据结构：**索引节点（inode）**和**目录项（directory entry）**。

- 索引节点：包含文件元信息（inode 号、类型、大小、权限、位置、时间戳等）。
- 目录项：文件名与索引节点的映射关系。

磁盘最小读写单位是扇区（sector），通常为 512 字节。Linux 逻辑块为 4KB。文件系统通过块设备驱动程序与磁盘交互。

磁盘格式化时划分为三个区域：

1. **超级块（Superblock）**：文件系统元信息。
2. **索引节点表（Inode Table）**：存储所有文件的索引节点。
3. **数据块（Data Block）**：存储文件的实际数据内容。

| 磁盘文件系统 | Linux 文件系统架构 |
|---|---|
| ![inode](inode.png) | ![file](file.png) |

---

## 3.1 虚拟文件系统（VFS）

Linux 内核实现了虚拟文件系统（VFS），为不同类型的文件系统提供统一接口。VFS 定义了一组抽象数据结构和函数，使用户空间程序可以透明访问不同类型的文件系统。

Linux 支持三类文件系统：

1. 磁盘文件系统（如 ext4、xfs、btrfs）
2. 网络文件系统（如 NFS、CIFS）
3. 内存文件系统（如 /tmp、/dev）

---

## 3.2 文件描述符

操作系统为每个进程维护一个文件描述符表（File Descriptor Table），每个文件描述符（FD）是一个整数索引，指向内核中的文件对象。文件描述符表内维护：

- 文件对象指针
- 当前偏移量
- 文件打开计数器
- 访问权限

进程以字节读取文件，操作系统以数据块为单位读写。文件系统屏蔽了这种差异。

---

## 3.3 文件存储

文件的数据存储在硬盘上，有连续存储和离散存储两种方式。

1. **连续存储**：文件头指定起始位置和长度，优点是读写快，缺点是易碎片化。
2. **离散存储**：
   - 链接存储：如 FAT，显式链表或隐式链表。
   - 索引存储：如 inode，文件头指向索引节点，索引节点包含所有数据块指针。
   - 链式 + 索引：支持更大文件。
   - 多级索引：索引节点中存储指向其他索引节点的指针，支持超大文件。

Unix（Ext 2/3）综合了上述方式的优点，采用直接、一级、二级、三级间接索引。

---

## 3.4 磁盘空间管理

磁盘空间管理有空间链表法（Free List）和位图法（Bitmap）。位图法查找空闲块快，但单块位图只能表示有限空间，Linux 采用多级位图。

Linux Ext2 文件系统结构如下：

![multi-level bitmap](bitmap.png)

每个块组包含超级块、块位图、索引节点位图和索引节点表。

目录也是一个文件，目录项存储在目录文件中。每个目录项包含文件名和 inode 号。目录文件可线性存储（如 ext2）、哈希存储（如 ext4）。

---

## 3.5 符号链接和硬链接

- **符号链接（Symbolic Link）**：特殊文件，内容是另一个文件的路径，可跨文件系统。
- **硬链接（Hard Link）**：多个目录项指向同一个 inode，只能在同一文件系统内创建，所有硬链接删除后文件才真正删除。

---

## 3.6 I/O 类型

### 1. 缓冲与非缓冲 I/O

- **缓冲 I/O**：通过标准库函数（如 `fopen()`、`fread()`、`fwrite()`），在内存中维护缓冲区，减少系统调用开销。
- **非缓冲 I/O**：直接通过系统调用（如 `open()`、`read()`、`write()`、`close()`），更接近底层操作。

| Page Cache |
|---|
| ![pageCache](pageCache.png) |

---

### 2. 直接与非直接 I/O

- **非直接 I/O**（默认）：通过页缓存读写，由内核决定何时写入磁盘。
- **直接 I/O**：数据直接从用户空间读写到磁盘，不经过页缓存。需 `open()` 时加 `O_DIRECT` 标志，或用 `posix_fadvise()`、`aio_read()`、`aio_write()` 等异步接口。

---

### 3. 阻塞与非阻塞 I/O

- **阻塞 I/O**：如 `read()`、`write()`、`accept()`、`recv()`、`send()`，默认会阻塞线程直到数据准备好。
- **非阻塞 I/O**：通过 `fcntl()` 设置 `O_NONBLOCK`，调用立即返回。
- **I/O 多路复用**：`select()`、`poll()`、`epoll_wait()` 等，允许线程阻塞等待多个 I/O 事件。

---

### 4. 同步与异步 I/O

- **同步 I/O**：如 `read()`、`write()`、`select()`、`poll()`、`epoll_wait()`，线程需等待数据拷贝完成。
- **异步 I/O**：如 `aio_read()`、`aio_write()`（POSIX AIO）、`io_submit()`、`io_getevents()`（Linux AIO）、`io_uring`，线程发起 I/O 请求后立即返回，内核完成后通过回调或事件通知应用程序。

---