---
title: 操作系统学习笔记
date: 2025-07-28
category: 渐入佳境
tags: [操作系统, 进程管理, 内存管理, 文件系统]
---

操作系统的知识可以分为五个部分：进程管理、内存管理、文件系统、设备管理、网络系统。这里的网络系统主要是操作系统如何处理网络通信。仅仅照着知识抄笔记是没有用的，重要的是通过理解结合实践来形成自己的知识体系，并且有能力表达出来。

# 1. 进程管理

## 1.1 进程
### 1.1.1 进程状态

进程 process 定义为正在执行的程序的实例。它是操作系统资源分配和调度的基本单位。一个完整的进程状态变迁包括：

![process_state](process_state.drawio.png)

为了避免阻塞状态的进程占据物理内存，虚拟内存技术允许操作系统将阻塞进程的数据存储在磁盘上，只有在需要时才加载到内存中。也因此需要一个中间状态描述进程没有占据物理内存的状态 —— 挂起状态。挂起状态可分为两种：挂起就绪（进程在外存，只要进入内存就执行）和挂起阻塞（进程在外存等待）。

![process_state2](process_state2.drawio.png)

进程挂起的原因有：系统资源不足、进程主动挂起、操作系统调度策略、用户 Ctrl + C/Ctrl + Z 等。

### 1.1.2 进程控制

进程控制块（PCB）是操作系统用来管理进程的核心数据结构。它包含了进程的所有信息：
- 进程标识信息：如进程ID（pid）、用户ID（uid），用于唯一标识和归属进程。
- 进程状态信息：记录进程当前所处的状态（如新建、就绪、运行、阻塞、挂起等）。
- 优先级和调度信息：进程的优先级、调度相关参数，决定进程获得CPU的顺序。
- 资源分配信息：进程所占用的内存空间、打开的文件列表、使用的I/O设备等资源清单。
- CPU相关信息：如寄存器内容、程序计数器（PC）、堆栈指针等，用于进程切换时保存和恢复运行环境。
- 进程间关系信息：如父进程、子进程等层级关系。

将具有相同状态的进程的 PCB 链在一起，组成各种队列：就绪队列、阻塞队列、挂起就绪队列、挂起阻塞队列等。CPU 的核心（执行硬件单元）通过调度算法从就绪队列中选择一个进程执行。调度算法可以是先来先服务（FCFS）、短作业优先（SJF）、轮转（RR）等。

进程控制指的是操作系统对进程的创建、终止、阻塞、唤醒等操作。进程的创建通常由系统调用 `fork()` 实现，它会复制当前进程的 PCB，分配资源后插入就绪队列。新创建的进程会获得一个新的进程ID（pid），并且其父进程ID（ppid）指向原进程。终止进程则通过 `exit()` 系统调用完成，操作系统会清理该进程的资源并更新相关队列。阻塞进程通常是因为等待某些事件（如I/O操作完成），进程也可以主动调用 `sleep()` 等函数进入阻塞状态。一旦进程被阻塞只能等待事件的发生或由其他进程唤醒。

### 1.1.3 进程的上下文切换

操作系统在多任务环境下，保存当前进程的状态信息（上下文）在 PCB 中，并从另一个进程的 PCB 中加载状态信息。进程的状态信息（上下文）包括：用户空间的虚拟内存、全局变量、栈，还包括内核空间的内核堆栈、寄存器内容等。上下文切换一般发生在：进程时间片用完、进程阻塞等待I/O、进程主动让出CPU等。

## 1.2 线程

线程是相对于进程更小的，独立运行的基本执行单位。线程既可以并发运行（具有自己的寄存器状态和栈），同时又共享进程的资源（如内存空间、文件描述符等）。线程的创建和管理比进程更轻量级，因为线程之间的切换不需要像进程那样保存和恢复完整的上下文。对于统一进程内的线程，切换时只需切换不共享的数据（私有数据、寄存器）即可。线程的缺点是，当一个线程崩溃时，整个进程都会受到影响，因为它们共享同一地址空间。

总结性地说，线程是进程中的一条执行流程。两者相比，线程的创建和销毁开销更小，切换速度更快，但线程之间的共享资源也带来了更多的同步和安全问题。

目前主要有三种线程模型：用户级线程（User-Level Threads, ULT）、内核级线程（Kernel-Level Threads, KLT）和轻量级进程（Lightweight Process, LWP）。用户级线程由用户空间的库管理，内核不感知线程的存在；内核级线程由操作系统内核直接管理，内核可以调度和管理每个线程；轻量级进程则是介于两者之间的模型，允许多个用户级线程映射到一个或多个内核级线程（多对一、一对一、多对多）。

操作系统不参与用户线程的调度和管理（直接调度进程），而是通过线程库（如 pthreads）来实现用户级线程的创建、同步和销毁。内核级线程则由操作系统内核直接调度，支持多核处理器的并行执行。

- 用户线程的优点
  - TCB 由用户空间的线程库函数管理，每个进程都需要维护自己的线程控制块（TCB），无需内核支持。
  - 线程之间的切换不需要进行用户态和内核态的切换，切换速度快。
- 用户线程的缺点
  - 内核无法感知用户线程的存在，无法进行调度和管理。
  - 在多线程运行时，每个线程分到的时间片相较于其他进程会更少，可能导致线程饥饿。
- 内核线程的优点
  - 内核可以感知线程的存在，能够进行调度和管理。
  - 支持多核处理器的并行执行，可以充分利用多核 CPU 的性能。
- 内核线程的缺点
  - 切换线程时需要进行用户态和内核态的切换，切换速度相对较慢。
  - 内核需要维护每个线程的 TCB，增加了内核的复杂性和开销。
- 轻量级进程 LWP 是内核支持的用户线程，与内核线程一一映射，由内核管理调度。
  - 一对一：每个用户线程对应一个内核线程，内核可以独立调度每个线程。
  - 多对一：多个用户线程对应一个内核线程，内核只调度这个内核线程。
  - 一对多：一个用户线程对应多个内核线程，内核可以同时调度这些内核线程。

## 1.3 调度

线程才是操作系统调度的基本单位。调度算法决定了哪个线程在何时获得 CPU 的使用权。在进程状态切换时会触发调度（操作系统需要考虑当前进程的状态和优先级）。根据硬件时钟中断时操作系统是否进行调度，可以将调度分为两种类型：
- 非抢占式调度：操作系统不会在进程运行时强制切换进程，只有在进程主动让出 CPU 或阻塞时才进行调度。
- 抢占式调度：操作系统可以在任何时候强制切换进程，通常是通过硬件时钟中断来实现。（开销较大）

调度算法应该考虑以下几个方面： CPU 利用率尽量高，系统吞吐量尽量高（短任务优先）、周转时间尽量短（运行时间、阻塞时间、等待时间），等待时间（就绪状态）尽量短，响应时间尽量短（交互式系统），公平性（每个进程都能获得 CPU 的使用权）。

常见的调度算法：
- 单核 CPU 系统
  1. 先来先服务（FCFS）：按照进程到达的顺序进行调度，简单但可能导致长作业阻塞短作业。
  2. 短作业优先（SJF）：优先调度运行时间短的进程，平均等待时间最短，但可能导致长作业饥饿。
  3. 时间片轮转（RR）：每个进程分配一个时间片，时间片用完后强制切换到下一个进程，适合交互式系统。
  4. 优先级调度：根据进程的优先级进行调度，高优先级进程优先获得 CPU 使用权。
  5. 多级反馈队列（MLFQ）：将进程分为多个优先级队列，允许进程在不同队列间动态调整。
